
%---------------------------------------------------------------------
%
%                          Capítulo 3
%
%---------------------------------------------------------------------

\chapter{Desarrollo}

\begin{FraseCelebre}
\begin{Frase}
 Quisiera vivir para estudiar, \\
  no estudiar para vivir.
\end{Frase}
\begin{Fuente}
Sir Francis Bacon	
\end{Fuente}
\
\end{FraseCelebre}

\begin{resumen}
Para la correcta funcionalidad del proyecto, ha sido necesario configurar el hardware de forma precisa, además de desarrollar un software muy concreto y diseñado a medida para el contexto en el que trabajamos. En este capítulo se exponen los factores fundamentales de ambos ámbitos con cierto nivel de profundidad.
\end{resumen}

%-------------------------------------------------------------------
\section{Proyecto inicial}
%-------------------------------------------------------------------
\label{cap3:sec:inicial}

Tras haber realizado la elección del tema en el que se basaría nuestro trabajo de fin de grado, así como tras la elección del director que dirigiría dicho trabajo, estábamos ansiosos de empezar lo antes posible e introducirnos en la materia. Nos pareció apasionante la idea de poder desarrollar software para dispositivos empotrados, y aun más, sabiendo que el campo con el que estaría íntimamente relacionado sería la medicina. Tras los sabios consejos que nos transmitió Joaquín sobre que placa concreta usar, de que hardware podríamos disponer para la realización del proyecto, así como el software que se nos podría facilitar, estábamos decididos a comenzar. La placa hardware sobre la que desarrollaríamos finalmente se trataba de una BeagleBone Black.

Inicialmente, Joaquín nos proporcionó un pequeño proyecto sobre el que poder comenzar a trabajar y sentar las bases de un proyecto mucho mayor. Este proyecto además podía funcionar correctamente con diversos chips de Texas Instruments, concretamente nosotros escogimos el chip ADS1198. Este chip generaba simulaciones de muestras de forma continua. El código proporcionado era relativamente sencillo y fácil de entender. Se trataba de un programa realizado en C capaz de leer en espacio de usuario del dispositivo (en nuestro caso la BBB). Es decir, era capaz de recibir y tratar toda la información recibida de forma continua por el chip ADS1198. Hasta aquí todo es relativamente sencillo, gracias al protocolo SPI y al programa de usuario en C era posible gestionar toda la información recibida de las muestras simuladas y realizar el tratamiento pertinente. El único problema hasta aquí es que realmente no era posible gestionar toda la información, si no más bien, casi toda la información.



%-------------------------------------------------------------------
\subsection{Objetivos}
%-------------------------------------------------------------------
\label{cap3:subsec:objetivos}

En ciertos contextos, la pérdida de cierto número de muestras puede ser despreciable y no requerir mayor atención. Sin embargo, en este contexto concreto, al tratarse de procesamiento de señales en tiempo real, la pérdida de un cierto número de muestras, por pequeña que sea, puede ser decisiva a la hora de interpretar la información. El programa inicial escrito en C registraba una pérdida de muestras, que se podía determinar fácilmente hallando la diferencia entre el número de muestras generadas y el número de muestras leídas en el espacio de usuario. 

El conjunto total de muestras que se perdía durante la transmisión de información era variable según distintas condiciones y factores externos que influyesen en el momento de la recopilación de información. Generalmente, si únicamente se ejecutaba el programa de usuario sin tener otras aplicaciones que consumiesen muchos recursos tanto de memoria como de cálculo computacional  en la BBB, la suma total de muestras perdidas podía encontrarse entre el 1 y el 2\% del total de muestras generadas. Sin embargo, si mientras se ejecutaba el programa en C, se ejecutaba algún otro programa que necesitase algún tipo de recurso para ser ejecutado, el número de muestras perdidas por la lectura en espacio de usuario podía dispararse. 

Observamos que al ejecutar incluso ciertos comandos de consola, podría llegar a darse la situación anteriormente nombrada. Suponiendo que la ejecución del programa se realiza sobre un sistema operativo anfitrión con alguna distribución Linux ejecutándose (en nuestro caso se trataba de una distribución Debian especial para la placa BBB), si tratábamos de ejecutar un comando como \texttt{top} \footnote{Más información sobre el comando top disponible en \href{https://linux.die.net/man/1/top}{https://linux.die.net/man/1/top}} (que muestra las tareas que esten ejecutándose en la máquina anfitriona en tiempo real y actualizándolas en intervalos cortos de tiempo como puede apreciarse en la [Fig \ref{fig:top}]), el número de muestras perdidas aumentaba de forma exponencial. Es decir, para que las pérdidas realmente no fuesen significativas, el dispositivo sobre el que se ejecutase el programa, no debería estar ejecutando nada adicional, o al menos no muchas más aplicaciones. Siendo conscientes de la baja probabilidad de que esta situación se diese en un entorno real, sabíamos que algo teníamos que hacer para evitar esa pérdida de muestras en cualquier situación. Esta pérdida era básicamente producida por interrupciones que lanzaba el propio sistema operativo anfitrión cuando fuese preciso, otorgando la \ac{CPU} a otros procesos que no fuesen el programa que recogía las muestras durante cierto tiempo, suficiente para significar una pérdida representativa.

\figura{Vectorial/top}{width=1\textwidth}{fig:top}%
{Ejemplo de salida al ejecutar comando \texttt{top} en una terminal linux}

Sabiendo que el sistema operativo no tenía por qué garantizarnos la CPU para el programa de usuario durante la mayor parte del tiempo que este se encuentra en ejecución, tuvimos que investigar la mejor forma de poder solucionar este problema.

%-------------------------------------------------------------------
\subsection{Alternativas}
%-------------------------------------------------------------------
\label{cap3:subsec:alternativas}

Teniendo en mente el problema anteriormente nombrado, era momento de buscar alternativas para solventarlo. La solución más inmediata que pasó por nuestra cabeza, fue la de sustituir la distribución Debian que utilizábamos en la BBB por una distribución que estuviese pensada para trabajar con análisis y tratamientos de datos en tiempo real. De esta forma, el sistema operativo no interrumpiría el proceso de análisis de muestras otorgando la CPU a otras tareas, y por consiguiente, presumiblemente no se produciría la pérdida de ninguna muestra. Sin embargo está solución parecía poco sostenible, ya que el hecho de recurrir a una distribución tan específica podría no ser accesible para todo tipo de usuarios y dispositivos, sin olvidar la dependencia que se generaría hacia ese sistema operativo concreto, impidiendo con la más absoluta de las certezas que funcionase exitosamente en otros tipo de sistemas operativos (ya que por decirlo de algún modo, sería como un traje a medida). Sin embargo, si se utilizase una distribución genérica, como el Debian que usábamos en aquel momento, no habría problemas, ya que se trata de una distribución de propósito general a la que cualquier usuario podría recurrir de manera relativamente sencilla.

Una vez estábamos decididos a mantener el sistema operativo, la solución tenía que encontrarse explorando otras posibles vías. Fue entonces, cuando se nos presentó la posibilidad de usar dos microprocesadores que tenía la BBB, cada uno denominado \ac{PRU}. Estos dos microprocesadores con los que contábamos, podían ser programados específicamente para tratar procesos de análisis y recopilación de muestras en tiempo real. De esta forma, aunque el sistema operativo decidiese ceder el uso de la CPU a otro proceso, las PRUs podrían seguir tratando los procesos en tiempo real en segundo plano, sin necesidad de requerir la CPU principal, por lo que la pérdida de muestras se reduciría totalmente gracias a estos pequeños procesadores que incorpora la placa. Se trata de dos procesadores de alta frecuencia (200-MHz) de arquitectura de 32 bits que ofrecen la posibilidad a los desarrolladores de tratar con operaciones en tiempo real.

A continuación se enumeran los motivos por los que escogimos recurrir a las PRUs:

\begin{itemize}
  \item Tienen acceso a los pins, así como a la memoria interna de la BBB y a los periféricos del principal procesador principal que incorpora.
  \item Están diseñados para proveer software específico para periféricos como parte del sistema PRU-ICSS (Programmable Real-time Unit Industrial Control SubSystem).
  \item Son capaces de implementar soluciones relativamente simples a problemas complejos.
  \item Consta de un gran ancho de banda para comunicarse con la CPU principal y sus controladores, por lo que es improbable que se produzca el fenómeno conocido como cuello de botella. \footnote{Se denomina cuello de botella a la situación que se presenta cuando en un proceso productivo, una fase de producción es más lenta que otras, lo que ralentiza el proceso de producción global.}
  \item Existen multitud de recursos y proyectos en los que se utilizan estos procesadores, que pueden ser consultados de forma libre y gratuita en la red.
\end{itemize}

%-------------------------------------------------------------------
\section{Programación en tiempo real}
%-------------------------------------------------------------------
\label{cap3:sec:tiemporeal}

Abordar la decisión de trabajar con las PRUs no es una tarea trivial. Requiere una gran labor de investigación previa, así como una sólida base en ciertos lenguajes de programación. Además, han sido necesarias tomar ciertas decisiones que han resultado cruciales para el correcto avance y desarrollo del proyecto, como ha podido ser en qué lenguaje programar las PRUs, o la configuración hardware para trabajar en el desarrollo.

%-------------------------------------------------------------------
\subsection{Decisiones de diseño}
%-------------------------------------------------------------------
\label{cap3:subsec:decisiones}

Cuando comenzó el desarrollo de este proyecto, existían dos posibles alternativas a escoger a la hora de elegir lenguaje con el que trabajar en las PRUs: 

\begin{itemize}
  \item \textbf{Posibilidad de programar en C:} Texas instruments introdujo en una de las últimas versiones de Code Composer Studio (Es un entorno de desarrollo integrado que soporta microcontroladores de Texas Instruments y otro tipo de procesadores empotrados) \footnote{Más información sobre este entorno de desarrollo en \href{http://www.ti.com/tool/ccstudio}{http://www.ti.com/tool/ccstudio}} la posibilidad de programar en C para programar las PRU. Las herramientas que proporciona Texas Instruments para ello se denominan CGT (Code Generation Tools) y son relativamente sencillas de utilizar.
   \item \textbf{Posibilidad de programar en ensamblador:} Hay dos tipos de ensamblador disponibles para la PRU, pasm y clpru.
   \begin{itemize}
   		\item Pasm es el ensamblador original para la PRU. Este ensamblador suporta una unidad de traducción simple y se monta directamente a una imagen binaria (u otros formatos compatibles).
   		 \item Clpru es actualmente una herramienta de compilación completa que incluye ensamblador para la programación de la PRU. Soporta multitud de unidades de traducción y se monta directamente sobre ficheros objetos, los cuales deben ser enlazados al ejecutable final. \footnote{Cabe destacar que tanto pasm como clpru soportan prácticamente la misma sintaxis.}
   \end{itemize}
\end{itemize}

Ante las alternativas que se nos plantearon, la decisión final fue la de programar en ensamblador, concretamente en pasm, ya que resultó ser una de las opciones más interesantes para este proyecto (aunque somos conscientes de que en la actualidad no es frecuente encontrarse con una situación en la que se requiera programar en ensamblador). Se optó por esta decisión de diseño, ya que investigar cual de las posibilidades era la que más flexibilidad podía aportar al contexto en el que se situaba el proyecto, pasm resultó aportar un mayor control y una valiosa posibilidad de optimizar el código final.

%-------------------------------------------------------------------
\section{Configuración hardware}
%-------------------------------------------------------------------
\label{cap3:sec:config}

Tal y como indicabamos en la sección \ref{cap2:subsec:bbb}, la BBB es un dispositivo que aporta una gran flexibilidad a los desarrollares, gracias a la facilidad que supone ampliar su funcionalidad con multitud de tipos de placas de expansión opcionales. 

\figura{Vectorial/pins}{width=1\textwidth}{fig:pins}%
{Diagrama de conexiones físicas disponibles en una BBB}

Cada uno de los pines físicos que incorpora la placa tiene una función determinada como puede apreciarse en la [Fig \ref{fig:pins}]. La BBB dispone de dos cabeceras completas (conocidas como P8 y P9) con multitud de pines disponibles, que permiten realizar conexiones físicas mediante cableado. La leyenda de la [Fig \ref{fig:pins}] muestra las funciones, o mejor dicho, las posibles funciones de los distintos pines:

\begin{itemize}
\item Para empezar, se han destacado en color rojo los pines de 5, 3 y 1.8 \textit{Voltios}, así como los pines de tierra (DGND). Hay que tener en cuenta que VDD\_ ADC es un pin de 1.8 \textit{V} que se usa para proporcionar una referencia para las funciones de lectura analógica.
\item Los pines \ac{GPIO} están destacados en color verde. Cabe destacar que algunos  de estos pines se pueden usar para comunicación serie (UART) \footnote{\label{note1}Más información sobre UART e I2C disponible en \href{https://geekytheory.com/puertos-y-buses-1-i2c-y-uart}{https://geekytheory.com/puertos-y-buses-1-i2c-y-uart}}.
\item Si se desea simular una salida analógica comprendida entre 0 y 3.3 \textit{V}, se pueden usar los pines PWM destacados en morado. 
\item Los pines destacados en color azul pueden ser utilizados como entradas analógicas \footnote{Estas entradas analógicas toleran voltajes comprendidos entre los 0 y los 1.8 \textit{Voltios}, no soportan voltajes superiores a los 1.8 \textit{V}}. 
\item Los pines en color naranja clarito pueden ser usados para I2C \textsuperscript{\ref{note1}}.
\item Los pines destacados en color naranja oscuro son fundamentalmente usados para aplicaciones de pantalla \ac{LCD}.
\end{itemize}

%-------------------------------------------------------------------
\subsection{Device Tree}
%-------------------------------------------------------------------
\label{cap3:subsec:dt}

Un \ac{DT} es una descripción del hardware de un sistema. Debería incorporar el nombre de la CPU, la configuración de memoria, y cualquier periférico (interno y externo). Un DT no debería ser usado para describir software, a pesar de que listar los módulos hardware pueda causar que estos se carguen. Es preciso recordar que los DTs son neutros en lo que se refiere al sistema operativo, es decir, no deberían incluir nada específico de Linux por ejemplo.


\figura{Vectorial/dt}{width=1\textwidth}{fig:dt}%
{Ejemplo simple de un fichero \texttt{.dts}}

Un DT representa la configuración hardware como si de una jerarquía de nodos se tratase. Cada nodo puede contener propiedades y subnodos. Las propiedades se denominan arrays de bytes, los cuales pueden contener strings, números (big-endian), secuencias arbitrarias de bytes, y cualquier combinación de estos. Por analogía con un sistema de ficheros, los nodos son directorios, y las propiedades son ficheros. 

Los DT generalmente se encuentran en un formato textual conocido como Device Tree Source (DTS) y son almacenados en ficheros con extensión \texttt{.dts}. La sintaxis DTS es como la de C, con llaves para agrupar código y punto y coma para concluir cada línea. En la [Fig \ref{fig:dt}] puede apreciarse un ejemplo muy simple de este tipo de ficheros.

Cabe destacar que los DTS requieren de punto y coma tras el cierre de una llave. El formato del binario compilado es denominado Flattened Device Tree (DFT) o Device Tree Blob (DTB), y se almacena en ficheros con extensión \texttt{.dtb}. 

%-------------------------------------------------------------------
\subsection{Device Tree Overlay}
%-------------------------------------------------------------------
\label{cap3:subsec:dto}

Un SoC (System-on-Chip moderno) moderno es un dispositivo muy complejo; un DT completo podría suponer cientos de líneas de código. Situar un SoC en una placa junto a otros componentes solo hace que las cosas sean aun más complejas. Para que sea relativamente manejable, especialmente si hay dispositivos relaciones que comparten componentes, tiene sentido diferenciar los elementos comunes en ficheros con extensión \texttt{.dtsi}, para que sean incluidos desde los ficheros \texttt{.dts} que los requiriesen.

Pero cuando una placa como la BBB es compatible con accesorios expandibles, el problema puede ser aun más complejo. En última instancia, cada configuración posible requiere un DT para ser descrita, pero una vez que se tenga en cuenta el hardware de base y las expansiones que requieren el uso de unos pines GPIO determinados que pueden ser compartidos por otras configuraciones diferentes, el número de combinaciones posibles comienza a multiplicarse rápidamente.

Lo que se necesita es una forma de describir estos componentes opcionales utilizando un DT parcial, y luego poder construir un árbol completo tomando un DT como base y añadiendo una serie de elementos opcionales. 
Estos elementos opcionales son denominados \textit{overlays}. Al DT que se forma siguiendo este proceso se le denomina \ac{DTO}.

\figura{Vectorial/dto}{width=1\textwidth}{fig:dto}%
{Device Tree Overlay del proyecto para la BBB}

Para nuestro proyecto, fue necesaria la creación y personalización de un DTO; la base sobre la empezamos esta creación fue la que se utiliza en el capítulo 13 de Exploring BBB  \citep{exploringBBB}. A partir de ahí se realizaron diversas modificaciones y expansiones para obtener un DTO hecho a medida acorde con las necesidades del proyecto. El resultado final del DTO que se obtuvo finalmente y que es utilizado actualmente en la BBB se ilustra en la [Fig \ref{fig:dto}]. El código final fue comentado de modo que pudiese ser interpretado y comprendido de forma sencilla. Como puede apreciarse en la imagen, el primer paso es indicar cuales van a ser los pines que se van a utilizar de forma exclusiva. A continuación se le asigna un modo a cada uno de los pines anteriormente indicado. De esta forma, el modo que se asigna, la señal que va a ir asociada a ese pin concreto y otra información complementaria puede ser encontrada en el código comentado. Cabe destacar que existen ciertas restricciones a la hora de asignar cierto modo a un pin determinado, ya que no a todos los pines se les puede asignar cualquier modo. En nuestro caso, solo determinados pines de la BBB tienen acceso a determinados modos que permiten interacciones tanto con la PRU0, como con la PRU1. Por ejemplo, el modo \texttt{pr1\_pru0\_pru\_r31\_7} solo puede ser asignado al pin P9\_25 (PRU0), y el modo \texttt{pr1\_pru1\_pru\_r31\_16} solo puede asignarse al pin P9\_26 (PRU1). Los dos ejemplos anteriormente comentados con puestos en práctica en nuestro DTO, aunque la lista de restricciones abarca muchos más modos y pines. Está información puede encontrarse más detallada en la [Fig \ref{fig:restricciones}]. Cabe destacar que este tipo de ficheros \texttt{.dts} sigue siempre una misma estructura en lo que al código respecta, aunque las posibles combinaciones de configuraciones hardware son prácticamente infinitas.

\figura{Vectorial/restricciones}{width=1\textwidth}{fig:restricciones}%
{Restricciones en la asignación de modos a pines relevantes para el proyecto}

%-------------------------------------------------------------------
\subsection{Conexiones físicas}
%-------------------------------------------------------------------
\label{cap3:subsec:conexiones}

Una vez diseñada la configuración hardware, era momento de realizar las conexiones físicas mediante cableado. Entre los objetivos que han de satisfacer estas conexiones físicas, cabe destacar los siguientes:

\begin{itemize}
\item Alimentar el ADS1198, ya que se alimenta a través de la BBB. 
\item Posibilitar la conexión SPI entre ambos dispositivos (ADS1198 y BBB).
\item Garantizar el uso de pines con fines GPIO (para cada una de las distintas señales).
\item Conectar el analizador lógico Saleae con cada una de las señales que see desee depurar.
\end{itemize}

\clearpage %esto es para que imprima las tablas juntas.

\begin{table}[]
\centering
\caption{Conexiones físicas necesarias para la alimentación del chip ADS1198}
\label{tabla1}
\begin{tabular}{|c|c|c|}
\hline
\textbf{BBB Pin} & \textbf{ADS1198 Pin} & \textbf{Uso de la conexión} \\ \hline
P9 Pin 1         & J4 Pin 5             & GND                         \\ \hline
P9 Pin 3         & J4 Pin 9             & 3.3V                        \\ \hline
P9 Pin 5         & J4 Pin 10            & 5V                          \\ \hline
\end{tabular}
\end{table}

\begin{table}[]
\centering
\caption{Conexiones físicas de carácter general GPIO}
\label{tabla2}
\begin{tabular}{|c|c|c|}
\hline
\textbf{BBB Pin} & \textbf{ADS1198 Pin} & \textbf{Señal asociada a la conexión} \\ \hline
P9 Pin 23        & J3 Pin 15            & DATA\_READY                           \\ \hline
P9 Pin 25        & J3 Pin 8             & RESET                                 \\ \hline
P9 Pin 27        & J3 Pin 14            & START                                 \\ \hline
\end{tabular}
\end{table}

\begin{table}[]
\centering
\caption{Conexiones físicas para posibilitar la conexión SPI}
\label{tabla3}
\begin{tabular}{|c|c|c|}
\hline
\textbf{BBB Pin} & \textbf{ADS1198 Pin} & \textbf{Señal asociada a la conexión} \\ \hline
P9 Pin 29        & J3 Pin 13            & SPI\_OUT                           \\ \hline
P9 Pin 30        & J3 Pin 11             & SPI\_IN                                 \\ \hline
P9 Pin 31        & J3 Pin 3             & SPI\_SCLK                                  \\ \hline
P9 Pin 28        & J3 Pin 1            & SPI\_CSO                                 \\ \hline
\end{tabular}
\end{table}

\begin{table}[]
\centering
\caption{Conexiones físicas del analizador lógico Saleae}
\label{tabla4}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Canal} & \textbf{ADS1198 Pin} & \textbf{Señal asociada a la conexión} \\ \hline
CH0        & J3 Pin 15           & DATA\_READY                           \\ \hline
CH1        & J3 Pin 3             & CLK                               \\ \hline
CH2        & J3 Pin 1            & CHIP\_SELECT                                \\ \hline
CH3        & J3 Pin 13            & DATA\_OUT                                \\ \hline
CH4        & J3 Pin 11             & DATA\_IN                              \\ \hline
CH5        & J3 Pin 8             & RESET                                 \\ \hline
CH6        & J3 Pin 14            & START                                 \\ \hline
CH7        & J4 Pin 5             & GND                              \\ \hline
\end{tabular}
\end{table}

\clearpage %esto es para que imprima las tablas juntas.

Una vez se han realizado las conexiones indicadas en las tablas \ref{tabla1}, \ref{tabla2}, \ref{tabla3} y \ref{tabla4}, puede considerarse que la configuración hardware ha concluido con éxito. En nuestro caso, el resultado de completar todas las conexiones físicas puede apreciarse en la [Fig \ref{fig:conexiones}].

\figura{Vectorial/conexiones}{width=1\textwidth}{fig:conexiones}%
{Conexiones físicas necesarias para el proyecto}

%-------------------------------------------------------------------
\section{Ecosistema software}
%-------------------------------------------------------------------
\label{cap3:sec:ecosistema}

El propósito de esta sección no es más que proporcionar al lector una idea general e intuitiva del modo de funcionamiento del ecosistema software, así como de sus relaciones internas, de forma que sea posible entender el contexto y la motivación de cada una de las acciones que se realizan en el software. 
La forma en la que se relaciona el ecosistema es bastante sencilla de entender, al menos, si no nos centramos en los complejos detalles técnicos referentes a la implementación de cada uno de los componentes.

El software más destacado que se ejecuta en la BBB es el siguiente:
\begin{itemize}
\item Programa principal desarrollado en C que se ejecuta en espacio de usuario denominado \texttt{medcape.c}.
\item Programa desarrollado en código ensamblador, del que se hablará con más detenimiento más adelante denominado \texttt{PRUADC.p}.
\item Programa desarrollado en C, denominado \texttt{mem2file.c} y encargado de la escritura de datos de memoria a un fichero externo.
\item Programa muy sencillo desarrollado en Python, y denominado \texttt{BTConnection.py} y encargado de la recepción y envío de información a otros dispositivos.
\end{itemize}

\figura{Vectorial/pru}{width=0.8\textwidth}{fig:pru}%
{Bancos de memoria del PRU}

La relación de este ecosistema es bastante simple. El programa principal \texttt{medcape.c}, el cual está programado para ejecutarse según enciende la BBB, es el encargado de realizar las inicializaciones pertinentes para que funcione el intercambio de información, de mapear ciertas regiones de memoria, de ejecutar el binario principal\footnote{Código ensamblador compilado que ejecuta el PRU, concretamente el fichero \texttt{PRUADC.p}}, así como de capturar y generar interrupciones hacia el código que ejecuta el PRU. De forma paralela a la ejecución del programa en C, se ejecuta el programa en ensamblador ya que se da la orden de ejecutar el binario desde el propio programa en C. 

El programa en C consta de un hilo que es el encargado de realizar las interacciones pertinentes con el código que se ejecuta en el PRU. Este hilo entra en modo de espera indefinido hasta que reciba una interrupción por parte del código ejecutándose en el PRU indicando que las muestras están listas y guardadas en el banco de memoria del PRU (Se ilustra más información sobre estos bancos de memoria en la [Fig \ref{fig:pru}]).

Cuando la recopilación del paquete de muestras está lista y almacenada en el banco de memoria del PRU, se manda una interrupción desde el código ensamblador al programa C que se encontraba en espera de capturar un evento concreto. La ejecución continua con una llamada al programa en C \texttt{mem2file.c}, encargado de acceder a las regiones concretas del banco de memoria del PRU en la que el código ensamblador ha guardado las muestras, y guardarlas en un fichero (generalmente con extensión \texttt{.data}). Además de guardarse en este fichero, el paquete de muestras es enviado por una tubería de la que ahora hablaremos.

Es en este momento cuando entra en juego el programa desarrollado en Python, que accede a la información de la tubería, la cual permite la sincronización y comunicación con otros procesos. El programa Python es capaz de enviar esta información a otros dispositivos, en nuestro caso concreto, se envía a un dispositivo móvil con sistema operativo Android como veremos con más detalle más adelante.

Una vez es asimilado el modo de funcionamiento del ecosistema, aunque sólo sea de forma intuitiva, es posible entrar en detalles técnicos más concretos y complejos, ya que es posible comprender el contexto del ecosistema software.

%-------------------------------------------------------------------
\subsection{Inicizalización ADS}
%-------------------------------------------------------------------
\label{cap3:sec:inicialización}

Una vez configurado correctamente el DTO (tal y como se comenta en la sección \ref{cap3:subsec:dto}), y realizadas las conexiones físicas pertinentes entre la BBB y el ADS1198, es necesario inicializar el ADS. Inicializar el ADS por software es fundamental. Con inicialización nos referimos a realizar la correcta configuración de una serie de parámetros que permita que ambos dispositivos se puedan comunicar correctamente ya que de no configurarlo con los parámetros adecuados no conseguiríamos establecer ningún tipo de conexión entre ambos, es decir, sería como si ni siquiera estuviesen conectados físicamente. Cabe destacar que la inicialización se realiza en código ensamblador, y a diferencia del lenguaje C, no existen bibliotecas que faciliten al desarrollador una capa superior de abstracción para realizar la tarea.

\figura{Vectorial/iniads}{width=0.9\textwidth}{fig:iniads}%
{Inicialización ADS en el código original en C}

En la Fig \ref{fig:iniads}] y se ilustra el proceso de inicialización del ADS en en el código del proyecto original. Es un código relativamente sencillo y completamente funcional. Los pasos que se siguen en el código original, desde resetear el ciclo, hasta la lectura de datos en modo continuo, son replicados en código ensamblador. El objetivo es conseguir la misma correcta funcionalidad de la que gozaba el código original.

\figura{Vectorial/senddatac}{width=1\textwidth}{fig:senddatac}%
{Función SDATAC en código ensamblador}

\figura{Vectorial/samplerate}{width=1\textwidth}{fig:samplerate}%
{Función SET\_ADS\_SAMPLE\_RATE en código ensamblador}

\figura{Vectorial/intref}{width=1\textwidth}{fig:intref}%
{Función SET\_INTERNAL\_REFERENCE en código ensamblador}

\figura{Vectorial/rdatac}{width=1\textwidth}{fig:rdatac}%
{Función SEND\_RDATAC en código ensamblador}

\clearpage 

En las anteriores figuras se ilustra un código en ensamblador funcional, utilizado y probado en el presente proyecto, que imita el funcionamiento del código original de inicialización del ADS en C.

%-------------------------------------------------------------------
\subsection{Comunicación SPI}
%-------------------------------------------------------------------
\label{cap3:sec:comunicacion}

La comunicación SPI funciona tal y como se explica en la sección \ref{cap2:subsec:bus}. El proceso de comunicación se realiza en ensamblador también. Comienza dando el valor activo bajo a la señal Chip Select como puede apreciarse en la figura [Fig \ref{fig:spiens}]. A continuación se lee o se escribe un número específico de bits, de forma que se llama a la función SPICLK\_LOOP tantas veces como bits se quieran leer o escribir. Cuando ha concluido este proceso, se da el valor activo alto a la señal Chip Select. De esta forma se indica que ha finalizado una muestra concreta. 

\figura{Vectorial/spiens}{width=1\textwidth}{fig:spiens}%
{Comunicación SPI en código ensamblador}

Cabe destacar que cada registro en ensamblador tiene una capacidad de 4 bytes. Debido al tamaño de cada muestra que se recoge, es necesario almacenar esta información en 7 registros. En la función SPICLK\_LOOP se utilizan los registros r16 como contador para saber cuantos bits se han recibido, y r20 como registro auxiliar. Considerando que el tamaño de cada muestra es de 18 bytes, cada una es almacenada de la siguiente forma:

\begin{itemize}
\item \textbf{Registro r3}: Primer registro (3 bytes)
\item \textbf{Registro r17}: Segundo registro (3 bytes)
\item \textbf{Registro r18}: Tercer registro (3 bytes)
\item \textbf{Registro r19}: Cuarto registro (3 bytes)
\item \textbf{Registro r20}: Quinto registro (3 bytes)
\item \textbf{Registro r23}: Sexto registro (3 bytes)
\item \textbf{Registro r27}: Séptimo registro (1 byte)
\end{itemize}

Esta información se refleja en forma de código en las figuras [Fig \ref{fig:loop1}] y [Fig \ref{fig:loop2}]. En estas figuras se muestra el código de la función SPICLK\_LOOP escrito en código ensamblador, en la cual se refleja el proceso de iteración sobre cada uno de los bits concretos, así como el uso de todos los registros anteriormente descritos.

\clearpage

\figura{Vectorial/loop1}{width=1\textwidth}{fig:loop1}%
{Función SPICLK\_LOOP en código ensamblador (primera parte)}

\figura{Vectorial/loop2}{width=1\textwidth}{fig:loop2}%
{Función SPICLK\_LOOP en código ensamblador (segunda parte)}

\clearpage

%-------------------------------------------------------------------
\subsection{Guardado de muestras en memoria}
%-------------------------------------------------------------------
\label{cap3:sec:guardado}

Según se van procesando las muestras, es necesario almacenarlas en algún sitio, para luego poder acceder a ellas desde el programa en C, del que se habla en la sección \ref{cap3:sec:lectura} (que a su vez vuelve a transmitir la información a otras vías). Es en este caso cuando entran en juego los bancos de memoria del PRU, en la que se almacenan de forma temporal todas las muestras que se recogen.

Este proceso de guardado de muestras en memoria se realiza en ensamblador. Para guardar la información de una muestra completa, se almacena la información almacenada en cada uno de los registros indicados en la sección \ref{cap3:sec:comunicacion}. Es decir, una vez todos estos registros están rellenos con la información de las muestras, el siguiente paso es el almacenamiento en memoria de cada uno de estos registros, que una vez guardados en posiciones de memoria consecutivas, reflejan el contenido de una muestra completa. 

Una vez se guardan las muestras, se lanza una interrupción del PRU hacia el programa principal en C, el cual se encuentra en ejecución y a la espera de una interrupción por parte del código ensamblador. Una vez capturada esta interrupción, la ejecución del código en C puede reanudarse (tal y como se explica en la sección \ref{cap3:sec:ecosistema}).

Todo este proceso se refleja en el código ensamblador, concretamente en la función STORE\_DATA. El contenido completo de esta función se muestra en las figuras [Fig \ref{fig:ram1}] y [Fig \ref{fig:ram2}].

\clearpage


\figura{Vectorial/ram1}{width=0.9\textwidth}{fig:ram1}%
{Función STORE\_RAM en código ensamblador (primera parte)}

\figura{Vectorial/ram2}{width=0.9\textwidth}{fig:ram2}%
 {Función STORE\_RAM en código ensamblador (segunda parte)}

\clearpage

%-------------------------------------------------------------------
\subsection{Lectura y transmisión de muestras}
%-------------------------------------------------------------------
\label{cap3:sec:lectura}

Como ya se adelantaba en la sección \ref{cap3:sec:guardado}, se ha desarrollado un programa en C encargado de leer la información de las muestras almacenadas en el banco de memoria del PRU, para posteriormente guardarla en un fichero (con extensión \texttt{.data}) \footnote{Este fichero binario está limitado por software a un tamaño máximo de 50MB}. Este programa en C está desarrollado a raíz de un ejemplo que se muestra en el cápitulo 13 del libro Exploring BeagleBone \citep{exploringBBB} y tanto ampliado como adaptado para su correcto funcionamiento en el presente proyecto.

Inicialmente, este programa crea el fichero en el que se guardarán los datos de las muestras. Accede al espacio de memoria del banco del PRU en la que se almacenan las muestras \footnote{Las muestras se almacenan por grupos de 100}. Es necesario asegurar que cada grupo de muestras contiene la información correcta y precisa, y para ello tras cada grupo de muestras se escriben dos bytes concretos, como si de un sello se tratase a modo de asegurar que los datos recibidos no sean corruptos o haya pérdidas. Concretamente tras el espacio exacto que requiere un grupo de muestras, se escriben a continuación los bytes \texttt{FF}.

El programa \texttt{mem2file.c} se asegura que contengan este identificador en el lugar exacto en el que corresponde. En caso de no encontrarlo, significa que no se ha escrito esta información aun, por lo que el programa sigue en bucle de espera hasta que la información se escriba. Sin embargo, si se encuentran estos dos bytes en el lugar específico tras cada grupo de muestras, es el propio programa el encargado de sustituir este sello por otros bytes distintos, a modo a su vez de indicador de que la muestra ha sido leída éxitosamente. Casi como si de otro sello (para confirmar la lectura) se tratase, se sustituyen los antiguos bytes por \texttt{00}.

Posteriormente se abre la tubería de Python (brevemente comentada en la sección \ref{cap3:sec:ecosistema})\footnote{La capacidad máxima de esta tubería es de 4KB}, y trata de enviarse la información por la misma en caso de haberse abierto correctamente. En la [Fig \ref{fig:mem2file}] se ilustra el proceso completo tras haberlo introducido brevemente.

\figura{Vectorial/mem2file}{width=1.1\textwidth}{fig:mem2file}%
{Función principal del programa \texttt{mem2file.c} desarrollado en C}

%\medskip

%Y también ponemos el acrónimo \ac{CVS} \footnote{Más información sobre UART e I2C disponible en \href{https://geekytheory.com/puertos-y-buses-1-i2c-y-uart}{https://geekytheory.com/puertos-y-buses-1-i2c-y-uart}}para que no cruja.


%-------------------------------------------------------------------
%\section*{\NotasBibliograficas}
%-------------------------------------------------------------------
%\TocNotasBibliograficas

%Citamos algo para que aparezca en la bibliografía\ldots
%\citep{ldesc2e}

%\medskip

%Y también ponemos el acrónimo \ac{CVS} para que no cruja.

%Ten en cuenta que si no quieres acrónimos (o no quieres que te falle la compilación en ``release'' mientras no tengas ninguno) basta con que no definas la constante \verb+\acronimosEnRelease+ (en \texttt{config.tex}).


%-------------------------------------------------------------------
%\section*{\ProximoCapitulo}
%-------------------------------------------------------------------
%\TocProximoCapitulo

%...

% Variable local para emacs, para  que encuentre el fichero maestro de
% compilación y funcionen mejor algunas teclas rápidas de AucTeX
%%%
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../Tesis.tex"
%%% End:
