
%---------------------------------------------------------------------
%
%                          Capítulo 3
%
%---------------------------------------------------------------------

\chapter{Desarrollo}

\begin{FraseCelebre}
\begin{Frase}
 Quisiera vivir para estudiar, \\
  no estudiar para vivir.
\end{Frase}
\begin{Fuente}
Sir Francis Bacon	
\end{Fuente}
\
\end{FraseCelebre}

\begin{resumen}
Aquí va el resumen del capitulo 3
\end{resumen}


%-------------------------------------------------------------------
\section{Proyecto inicial}
%-------------------------------------------------------------------
\label{cap3:sec:inicial}

Tras haber realizado la elección del tema en el que se basaría nuestro trabajo de fin de grado, así como tras la elección del director que dirigiría dicho trabajo, estabamos ansiosos de empezar lo antes posible e introducirnos en la materia. Nos pareció apasionante la idea de poder desarrollar software para dispositivos empotrados, y aun más, sabiendo que el campo con el que estaría íntimamente relacionado sería la medicina. Tras los sabios consejos que nos transmitió Joaquín sobre que placa concreta usar, de que hardware podríamos disponer para la realización del proyecto, así como el software que se nos podría facilitar, estabamos decididos a comenzar. La placa hardware sobre la que desarrollariamos finalmente se trataba de una BeagleBone Black.

Inicialmente, Joaquín nos proporcionó un pequeño proyecto sobre el que poder comenzar a trabajar y sentar las bases de un proyecto mucho mayor. Este proyecto además podía funcionar correctamente con diversos chips de Texas Instruments,concretamente nosotros escogimos el chip ADS1198. Este chip generaba simulaciones de muestras de forma continua. El código proporcionado era relativamente sencillo y fácil de entender. Se trataba de un programa realizado en C capaz de leer en espacio de usuario del dispositivo (en nuestro caso la BBB). Es decir, era capaz de recibir y tratar toda la información recibida de forma continua por el chip ADS1198. Hasta aquí todo es relativamente sencillo, gracias al protocolo SPI y al programa de usuario en C era posible gestionar toda la información recibida de las muestras simuladas y realizar el tratamiento pertinente. El único problema hasta aquí es que realmente no era posible gestionar toda la información, si no más bien, casi toda la información.



%-------------------------------------------------------------------
\subsection{Objetivos}
%-------------------------------------------------------------------
\label{cap3:subsec:objetivos}

En ciertos contextos, la pérdida de cierto número de muestras puede ser despreciable y no requerir mayor atención. Sin embargo, en este contexto concreto, al tratarse de procesamiento de señales en tiempo real, la pérdida de un cierto número de muestras, por pequeña que sea, puede ser decisiva a la hora de interpretar la información. El programa inicial escrito en C registraba una pérdida de muestras, que se podía determinar fácilmente hallando la diferencia entre el número de muestras generadas y el número de muestras leidas en el espacio de usuario. 

El conjunto total de muestras que se perdía durante la transmisión de información era variable según distintas condiciones y factores externos que influyesen en el momento de la recopilación de información. Generalmente, si únicamente se ejecutaba el programa de usuario sin tener otras aplicaciones que consumiesen muchos recursos tanto de memoria como de cálculo computacional  en la BBB, la suma total de muestras perdidas podía encontrarse entre el 1 y el 2\% del total de muestras generadas. Sin embargo, si mientras se ejecutaba el programa en C, se ejecutaba algún otro programa que necesitase algún tipo de recurso para ser ejecutado, el número de muestras perdidas por la lectura en espacio de usuario podía dispararse. 

Observamos que al ejecutar incluso ciertos comandos de consola, podría llegar a darse la situación anteriormente nombrada. Suponiendo que la ejecución del programa se realiza sobre un sistema operativo anfitrión con alguna distribución linux ejecutándose (en nuestro caso se trataba de una distribución Debian especial para la placa BBB), si tratabamos de ejecutar un comando como \texttt{top} \footnote{Más información sobre el comando top disponible en \href{https://linux.die.net/man/1/top}{https://linux.die.net/man/1/top}} (que muestra las tareas que esten ejecutándose en la máquina anfitriona en tiempo real y actualizadolas en intervalos cortos de tiempo como puede apreciarse en la [Fig \ref{fig:top}]), el número de muestras perdidas aumentaba de forma exponencial. Es decir, para que las pérdidas realmente no fuesen significativas, el dispositivo sobre el que se ejecutase el programa, no debería estar ejecutándo nada adicional, o al menos no muchas más aplicaciones. Siendo conscientes de la baja probabilidad de que esta situación se diese en un entorno real, sabíamos que algo teníamos que hacer para evitar esa pérdida de muestras en cualquier situación. Esta pérdida era básicamente producida por interrupciones que lanzaba el propio sistema operativo anfitrión cuando fuese preciso, otorgando la CPU a otros procesos que no fuesen el programa que recogía las muestras durante cierto tiempo, suficiente para significar una pérdida representativa.

\figura{Vectorial/top}{width=1\textwidth}{fig:top}%
{Ejemplo de salida al ejecutar comando \texttt{top} en una terminal linux}

Sabiendo que el sistema operativo no tenia por qué garantizarnos la CPU para el programa de usuario durante la mayor parte del tiempo que este se encuentra en ejecución, tuvimos que investigar la mejor forma de poder solucionar este problema.

%-------------------------------------------------------------------
\subsection{Alternativas}
%-------------------------------------------------------------------
\label{cap3:subsec:alternativas}

Teniendo en mente el problema anteriormente nombrado, era momento de buscar alternativas para solventarlo. La solución más inmediata que pasó por nuestra cabeza, fue la de sustituir la distribución Debian que utilizabamos en la BBB por una distribución que estuviese pensada para trabajar con análisis y tratamientos de datos en tiempo real. De esta forma, el sistema operativo no interrumpiría el proceso de análisis de muestras otorgando la CPU a otras tareas, y por consiguiente, presumiblemente no se produciría la pérdida de ninguna muestra. Sin embargo está solución parecía poco sostenible, ya que el hecho de recurrir a una distribución tan específica podría no ser accesible para todo tipo de usuarios y dispositivos, sin olvidar la dependencia que se generaría hacia ese sistema operativo concreto, impidiendo con la más absoluta de las certezas que funcionase éxitosamente en otros tipo de sistemas operativos (ya que por decirlo de algún modo, sería como un traje a medida). Sin embargo, si se utilizase una distribución genérica, como el Debian que usabamos en aquel momento, no habría problemas, ya que se trata de una distribución de proposito general a la que cualquier usuario podría recurrir de manera relativamente sencilla.

Una vez estabamos decididos a mantener el sistema operativo, la solución tenía que encontrarse explorando otras posibles vías. Fue entonces, cuando se nos presentó la posibilidad de usar dos microprocesadores que tenía la BBB, denominadas PRUs (programable real-time unit). Estos dos microprocesadores con los que contábamos, podían ser programados específicamente para tratar procesos de análisis y recopilación de muestras en tiempo real. De esta forma, aunque el sistema operativo decidiese ceder el uso de la CPU a otro proceso, las PRUs podrían seguir tratando los procesos en tiempo real en segundo plano, sin necesidad de requerir la CPU principal, por lo que la pérdida de muestras se reduciría totalmente gracias a estos pequeños procesadores que incorpora la placa. Se trata de dos procesadores de alta frecuencia (200-MHz) de arquitectura de 32 bits que ofrecen la posibilidad a los desarrolladores de tratar con operaciones en tiempo real.

A continuación se enumeran los motivos por los que escogimos recurrir a las PRUs:

\begin{itemize}
  \item Tienen acceso a los pins, así como a la memoria interna de la BBB y a los periféricos del principal procesador principal que incorpora.
  \item Estan diseñados para proveer software específico para periféricos como parte del sistema PRU-ICSS (Programmable Real-time Unit Industrial Control SubSystem).
  \item Son capaces de implementar soluciones relativamente simples a problemas complejos.
  \item Consta de un gran ancho de banda para comunicarse con la CPU principal y sus controladores, por lo que es improbable que se produzca el fenómeno conocido como cuello de botella. \footnote{Se denomina cuello de botella a la situación que se presenta cuando en un proceso productivo, una fase de producción es más lenta que otras, lo que ralentiza el proceso de producción global.}
  \item Existen multitud de recursos y proyectos en los que se utilizan estos procesadores, que pueden ser consultados de forma libre y gratuita en la red.
\end{itemize}

%-------------------------------------------------------------------
\section{Programación en tiempo real}
%-------------------------------------------------------------------
\label{cap3:sec:tiemporeal}

Abordar la decisión de trabajar con las PRUs no es una tarea trivial. Requiere una gran labor de investigación previa, así como una sólida base en ciertos lenguajes de programación. Además, han sido necesarias tomar ciertas decisiones que han resultado cruciales para el correcto avance y desarrollo del proyecto, como ha podido ser en qué lenguaje programar las PRUs, o la configuración hardware para trabajar en el desarrollo.

%-------------------------------------------------------------------
\subsection{Decisiones de diseño}
%-------------------------------------------------------------------
\label{cap3:subsec:decisiones}

Cuando comenzó el desarrollo de este proyecto, existían dos posibles alternativas a escoger a la hora de elegir lenguaje con el que trabajar en las PRUs: 

\begin{itemize}
  \item \textbf{Posibilidad de programar en C:} Texas instruments introdujó en una de las últimas versiones de Code Composer Studio (Es un entorno de desarrollo integrado que soporta microcontroladores de Texas Instruments y otro tipo de procesadores empotrados) \footnote{Más información sobre este entorno de desarrollo en \href{http://www.ti.com/tool/ccstudio}{http://www.ti.com/tool/ccstudio}} la posibilidad de programar en C para programar las PRU. Las herramientas que proporciona Texas Instruments para ello se denominan CGT (Code Generation Tools) y son relativamente sencillas de utilizar.
   \item \textbf{Posibilidad de programar en ensamblador:} Hay dos tipos de ensamblador disponibles para la PRU, pasm y clpru.
   \begin{itemize}
   		\item Pasm es el ensamblador original para la PRU. Este ensamblador suporta una unidad de traducción simple y se monta directamente a una imagen binaria (u otros formatos compatibles).
   		 \item Clpru es actualmente una herramienta de compilación completa que incluye ensamblador para la programación de la PRU. Soporta multitud de unidades de traducción y se monta directamente sobre ficheros objetos, los cuales deben ser enlazados al ejecutable final. \footnote{Cabe destacar que tanto pasm como clpru soportan prácticamente la misma sintaxis.}
   \end{itemize}
\end{itemize}

Ante las alternativas que se nos plantearon, la decisión final fue la de programar en ensamblador, concretamente en pasm, ya que resultó ser una de las opciones más interesantes para este proyecto (aunque somos conscientes de que en la actualidad no es frecuente encontrarse con una situación en la que se requiera programar en ensamblador). Se optó por esta descisión de diseño, ya que investigar cual de las posibilidades era la que más flexibilidad podía aportar al contexto en el que se situaba el proyecto, pasm resultó aportar un mayor control y una valiosa posibilidad de optimizar el código final.

%-------------------------------------------------------------------
\section{Configuración hardware}
%-------------------------------------------------------------------
\label{cap3:sec:config}

Tal y como indicabamos en la sección \ref{cap2:subsec:bbb}, la BBB es un dispositivo que aporta una gran flexibilidad a los desarrollares, gracias a la facilidad que supone ampliar su funcionalidad con multitud de tipos de placas de expansión opionales. 

\figura{Vectorial/pins}{width=1\textwidth}{fig:pins}%
{Diagrama de conexiones físicas disponibles en una BBB}

Cada uno de los pines físicos que incorpora la placa tiene una función determinada como puede apreciarse en la [Fig \ref{fig:pins}]. La BBB dispone de dos cabeceras completas (conocidas como P8 y P9) con multitud de pines disponibles, que permiten realizar conexiones físicas mediante cableado. La leyenda de la [Fig \ref{fig:pins}] muestra las funciones, o mejor dicho, las posibles funciones de los distintos pines:

\begin{itemize}
\item Para empezar, se han destacado en color rojo los pines de 5, 3 y 1.8 \textit{Voltios}, así como los pines de tierra (DGND). Hay que tener en cuenta que VDD\_ ADC es un pin de 1.8 \textit{V} que se usa para proporcionar una referencia para las funciones de lectura analógica.
\item Los pines de propósito general de entrada y salida (GPIO) están destacados en color verde. Cabe destacar que algunos  de estos pines se pueden usar para comunicación serie (UART) \footnote{\label{note1}Más información sobre UART e I2C disponible en \href{https://geekytheory.com/puertos-y-buses-1-i2c-y-uart}{https://geekytheory.com/puertos-y-buses-1-i2c-y-uart}}.
\item Si se desea simular una salida analógica comprendida entre 0 y 3.3 \textit{V}, se pueden usar los pines PWM destacados en morado. 
\item Los pines destacados en color azul pueden ser utilizados como entradas analógicas \footnote{Estas entradas analógicas toleran voltajes comprendidos entre los 0 y los 1.8 \textit{Voltios}, no soportan voltajes superiores a los 1.8 \textit{V}}. 
\item Los pines en color naranja clarito pueden ser usados para I2C \textsuperscript{\ref{note1}}.
\item Los pines destacados en color naranja oscuro son fundamentalmente usados para aplicaciones de pantalla LCD.
\end{itemize}

%-------------------------------------------------------------------
\subsection{Device Tree}
%-------------------------------------------------------------------
\label{cap3:subsec:dt}

Un Device Tree (DT) es una descripción del hardware de un sistema. Debería incorporar el nombre de la CPU, la configuración de memoria, y cualquier periférico (interno y externo). Un DT no deberia ser usado para describir software, a pesar de que listar los modulos harware pueda causar que estos se carguen. Es preciso recordar que los DTs son neutros en lo que se refiere al sistema operativo, es decir, no deberían incluir nada específico de Linux por ejemplo.


\figura{Vectorial/dt}{width=1\textwidth}{fig:dt}%
{Ejemplo simple de un fichero \texttt{.dts}}

Un DT representa la configuración hardware como si de una jerarquía de nodos se tratase. Cada nodo puede contener propiedades y subnodos. Las propiedades se denominan arrays de bytes, los cuales pueden contener strings, numeros (big-endian), secuencias arbitrarias de bytes, y cualquier combinación de estos. Por analogia con un sistema de ficheros, los nodos son directorios, y las propiedades son ficheros. 

Los DT generalmente se encuentran en un formato textual conocido como Device Tree Source (DTS) y son almacenados en ficheros con extensión \texttt{.dts}. La sintaxis DTS es como la de C, con llaves para agrupar código y punto y coma para concluir cada línea. En la [Fig \ref{fig:dt}] puede apreciarse un ejemplo muy simple de este tipo de ficheros.

Cabe destacar que los DTS requieren de punto y coma tras el cierre de una llave. El formato del binario compilado es denominado Flattened Device Tree (DFT) o Device Tree Blob (DTB), y se almacena en ficheros con extensión \texttt{.dtb}. 

%-------------------------------------------------------------------
\subsection{Device Tree Overlay}
%-------------------------------------------------------------------
\label{cap3:subsec:dto}

Un SoC (System-on-Chip moderno) moderno es un dispositivo muy complejo; un DT completo podría suponer cientos de líneas de código. Situar un SoC en una placa junto a otros componentes solo hace que las cosas sean aun más complejas. Para que sea relativamente manejable, especialmente si hay dispositivos relaciones que comparten componentes, tiene sentido diferenciar los elementos comunes en ficheros con extensión \texttt{.dtsi}, para que sean incluidos desde los ficheros \texttt{.dts} que los requiriesen.

Pero cuando una placa como la BBB es compatible con accesorios expandibles, el problema puede ser aun más complejo. En última instancia, cada configuración posible requiere un DT para ser descrita, pero una vez que se tenga en cuenta el hardware de base y las expansiones que requieren el uso de unos pines GPIO determinados que pueden ser compartidos por otras configuraciones diferentes, el número de combinaciones posibles comienza a multiplicarse rápidamente.

Lo que se necesita es una forma de describir estos componentes opcionales utilizando un DT parcial, y luego poder construir un árbol completo tomando un DT como base y añadiendo una serie de elementos opcionales. 
Estos elementos opcionales son denominados \textit{overlays}. Al DT que se forma siguiendo este proceso se le denomina Device Tree Overlay (DTO).

\figura{Vectorial/dto}{width=1\textwidth}{fig:dto}%
{Device Tree Overlay del proyecto para la BBB}

Para nuestro proyecto, fue necesaria la creación y personalización de un DTO; la base sobre la empezamos esta creación fue la que se utiliza en el capítulo 13 de Exploring BBB  \citep{exploringBBB}. A partir de ahi se realizaron diversas modificaciones y expansiones para obtener un DTO hecho a medida acorde con las necesidades del proyecto. El resultado final del DTO que se obtuvo finalmente y que es utilizado actualmente en la BBB se ilustra en la [Fig \ref{fig:dto}]. El código final fue comentado de modo que pudiese ser interpretado y comprendido de forma sencilla. Como puede apreciarse en la imagen, el primer paso es indicar cuales van a ser los pines que se van a utilizar de forma exclusiva. A continuación se le asigna un modo a cada uno de los pines anteriormente indicado. De esta forma, el modo que se asigna, la señal que va a ir asociada a ese pin concreto y otra información complementaria puede ser encontrada en el código comentado. Cabe destacar que existen ciertas resticciones a la hora de asignar cierto modo a un pin determinado, ya que no a todos los pines se les puede asignar cualquier modo. En nuestro caso, solo determinados pines de la BBB tienen acceso a determinados modos que permiten interacciones tanto con la PRU0, como con la PRU1. Por ejemplo, el modo \texttt{pr1\_pru0\_pru\_r31\_7} solo puede ser asignado al pin P9\_25 (PRU0), y el modo \texttt{pr1\_pru1\_pru\_r31\_16} solo puede asignarse al pin P9\_26 (PRU1). Los dos ejemplos anteriormente comentados con puestos en práctica en nuestro DTO, aunque la lista de restricciones abarca muchos más modos y pines. Está información puede encontrarse más detallada en la [Fig \ref{fig:restricciones}]. Cabe destacar que este tipo de ficheros \texttt{.dts} sigue siempre una misma estructura en lo que al código respecta, aunque las posibles combinaciones de configuraciones hardware son prácticamente infinitas.

\figura{Vectorial/restricciones}{width=1\textwidth}{fig:restricciones}%
{Restricciones en la asignación de modos a pines relevantes para el proyecto}

%-------------------------------------------------------------------
\subsection{Conexiones físicas}
%-------------------------------------------------------------------
\label{cap3:subsec:conexiones}

Una vez diseñada la configuración hardware, era momento de realizar las conexciones físicas mediante cableado. Entre los objetivos que han de satisfacer estas conexiones físicas, cabe destacar los siguientes:

\begin{itemize}
\item Alimentar el ADS1198, ya que se alimenta a través de la BBB. 
\item Posibilitar la conexión SPI entre ambos dispositivos (ADS1198 y BBB).
\item Garantizar el uso de pines con fines GPIO (para cada una de las distintas señales).
\item Conectar el analizador lógico Saleae con cada una de las señales que see desee depurar.
\end{itemize}

\clearpage %esto es para que imprima las tablas juntas.

\begin{table}[]
\centering
\caption{Conexiones físicas necesarias para la alimentación del chip ADS1198}
\label{tabla1}
\begin{tabular}{|c|c|c|}
\hline
\textbf{BBB Pin} & \textbf{ADS1198 Pin} & \textbf{Uso de la conexión} \\ \hline
P9 Pin 1         & J4 Pin 5             & GND                         \\ \hline
P9 Pin 3         & J4 Pin 9             & 3.3V                        \\ \hline
P9 Pin 5         & J4 Pin 10            & 5V                          \\ \hline
\end{tabular}
\end{table}

\begin{table}[]
\centering
\caption{Conexiones físicas de carácter general GPIO}
\label{tabla2}
\begin{tabular}{|c|c|c|}
\hline
\textbf{BBB Pin} & \textbf{ADS1198 Pin} & \textbf{Señal asociada a la conexión} \\ \hline
P9 Pin 23        & J3 Pin 15            & DATA\_READY                           \\ \hline
P9 Pin 25        & J3 Pin 8             & RESET                                 \\ \hline
P9 Pin 27        & J3 Pin 14            & START                                 \\ \hline
\end{tabular}
\end{table}

\begin{table}[]
\centering
\caption{Conexiones físicas para posibilitar la conexión SPI}
\label{tabla3}
\begin{tabular}{|c|c|c|}
\hline
\textbf{BBB Pin} & \textbf{ADS1198 Pin} & \textbf{Señal asociada a la conexión} \\ \hline
P9 Pin 29        & J3 Pin 13            & SPI\_OUT                           \\ \hline
P9 Pin 30        & J3 Pin 11             & SPI\_IN                                 \\ \hline
P9 Pin 31        & J3 Pin 3             & SPI\_SCLK                                  \\ \hline
P9 Pin 28        & J3 Pin 1            & SPI\_CSO                                 \\ \hline
\end{tabular}
\end{table}

\begin{table}[]
\centering
\caption{Conexiones físicas del analizador lógico Saleae}
\label{tabla4}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Canal} & \textbf{ADS1198 Pin} & \textbf{Señal asociada a la conexión} \\ \hline
CH0        & J3 Pin 15           & DATA\_READY                           \\ \hline
CH1        & J3 Pin 3             & CLK                               \\ \hline
CH2        & J3 Pin 1            & CHIP\_SELECT                                \\ \hline
CH3        & J3 Pin 13            & DATA\_OUT                                \\ \hline
CH4        & J3 Pin 11             & DATA\_IN                              \\ \hline
CH5        & J3 Pin 8             & RESET                                 \\ \hline
CH6        & J3 Pin 14            & START                                 \\ \hline
CH7        & J4 Pin 5             & GND                              \\ \hline
\end{tabular}
\end{table}

\clearpage %esto es para que imprima las tablas juntas.

Una vez se han realizado las conexiones indicadas en las tablas \ref{tabla1}, \ref{tabla2}, \ref{tabla3} y \ref{tabla4}, puede considerarse que la configuración hardware ha concluido con éxito. En nuestro caso, el resultado de completar todas las conexiones físicas puede apreciarse en la [Fig \ref{fig:conexiones}].

\figura{Vectorial/conexiones}{width=1\textwidth}{fig:conexiones}%
{Conexiones físicas necesarias para el proyecto}

%-------------------------------------------------------------------
\section{Inicizalización SPI y ADS}
%-------------------------------------------------------------------
\label{cap3:sec:inicialización}

%-------------------------------------------------------------------
\section{Comunicación SPI}
%-------------------------------------------------------------------
\label{cap3:sec:comunicacion}

%-------------------------------------------------------------------
\section{Guardado de muestras en RAM}
%-------------------------------------------------------------------
\label{cap3:sec:guardado}

%-------------------------------------------------------------------
\section{Lectura y transmisión de muestras}
%-------------------------------------------------------------------
\label{cap3:sec:lectura}


%\medskip

%Y también ponemos el acrónimo \ac{CVS} \footnote{Más información sobre UART e I2C disponible en \href{https://geekytheory.com/puertos-y-buses-1-i2c-y-uart}{https://geekytheory.com/puertos-y-buses-1-i2c-y-uart}}para que no cruja.


%-------------------------------------------------------------------
%\section*{\NotasBibliograficas}
%-------------------------------------------------------------------
%\TocNotasBibliograficas

%Citamos algo para que aparezca en la bibliografía\ldots
%\citep{ldesc2e}

%\medskip

%Y también ponemos el acrónimo \ac{CVS} para que no cruja.

%Ten en cuenta que si no quieres acrónimos (o no quieres que te falle la compilación en ``release'' mientras no tengas ninguno) basta con que no definas la constante \verb+\acronimosEnRelease+ (en \texttt{config.tex}).


%-------------------------------------------------------------------
%\section*{\ProximoCapitulo}
%-------------------------------------------------------------------
%\TocProximoCapitulo

%...

% Variable local para emacs, para  que encuentre el fichero maestro de
% compilación y funcionen mejor algunas teclas rápidas de AucTeX
%%%
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../Tesis.tex"
%%% End:
