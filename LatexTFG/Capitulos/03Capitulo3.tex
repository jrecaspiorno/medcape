%---------------------------------------------------------------------
%
%                          Capítulo 3
%
%---------------------------------------------------------------------

\chapter{Desarrollo}

\begin{FraseCelebre}
\begin{Frase}
 Quisiera vivir para estudiar, \\
  no estudiar para vivir.
\end{Frase}
\begin{Fuente}
Sir Francis Bacon	
\end{Fuente}
\
\end{FraseCelebre}

\begin{resumen}
Aquí va el resumen del capitulo 3
\end{resumen}


%-------------------------------------------------------------------
\section{Proyecto inicial}
%-------------------------------------------------------------------
\label{cap3:sec:inicial}

Tras haber realizado la elección del tema en el que se basaría nuestro trabajo de fin de grado, así como tras la elección del director que dirigiría dicho trabajo, estabamos ansiosos de empezar lo antes posible e introducirnos en la materia. Nos pareció apasionante la idea de poder desarrollar software para dispositivos empotrados, y aun más, sabiendo que el campo con el que estaría íntimamente relacionado sería la medicina. Tras los sabios consejos que nos transmitió Joaquín sobre que placa concreta usar, de que hardware podríamos disponer para la realización del proyecto, así como el software que se nos podría facilitar, estabamos decididos a comenzar. La placa hardware sobre la que desarrollariamos finalmente se trataba de una BeagleBone Black.

Inicialmente, Joaquín nos proporcionó un pequeño proyecto sobre el que poder comenzar a trabajar y sentar las bases de un proyecto mucho mayor. Este proyecto además requería el chip ADS1198. Este chip generaba simulaciones de muestras de forma continua. El código proporcionado era relativamente sencillo y fácil de entender. Se trataba de un programa realizado en C capaz de leer en espacio de usuario del dispositivo (en nuestro caso la BBB). Es decir, era capaz de recibir y tratar toda la información recibida de forma continua por el chip ADS1198. Hasta aquí todo es relativamente sencillo, gracias al protocolo SPI y al programa de usuario en C era posible gestionar toda la información recibida de las muestras simuladas y realizar el tratamiento pertinente. El único problema hasta aquí es que realmente no era posible gestionar toda la información, si no más bien, prácticamente toda la información.



%-------------------------------------------------------------------
\subsection{Objetivos}
%-------------------------------------------------------------------
\label{cap3:subsec:objetivos}

En ciertos contextos, la pérdida de cierto número de muestras puede ser despreciable y no requerir mayor atención. Sin embargo, en este contexto concreto, al tratarse de procesamiento de señales en tiempo real, la pérdida de un cierto número de muestras, por pequeña que sea, puede ser decisiva a la hora de interpretar la información. El programa inicial escrito en C registraba una pérdida de muestras, que se podía determinar fácilmente hallando la diferencia entre el número de muestras generadas y el número de muestras leidas en el espacio de usuario. 

El conjunto total de muestras que se perdía durante la transmisión de información era variable según distintas condiciones y factores externos que influyesen en el momento de la recopilación de información. Generalmente, si únicamente se ejecutaba el programa de usuario sin tener otras aplicaciones que consumiesen muchos recursos tanto de memoria como de cálculo computacional  en la BBB, la suma total de muestras perdidas podía encontrarse entre el 1 y el 2\% del total de muestras generadas. Sin embargo, si mientras se ejecutaba el programa en C, se ejecutaba algún otro programa que necesitase algún tipo de recurso para ser ejecutado, el número de muestras perdidas por la lectura en espacio de usuario podía dispararse. 

Observamos que al ejecutar incluso ciertos comandos en la terminal podría llegar a darse la situación anteriormente nombrada. Suponiendo que la ejecución del programa se realiza sobre un sistema operativo anfitrión con alguna distribución linux ejecutándose (en nuestro caso se trataba de una distribución Debian especial para la placa BBB), si tratabamos de ejecutar un comando como \texttt{top} \footnote{más información sobre el comando top disponible en \href{https://linux.die.net/man/1/top}{https://linux.die.net/man/1/top}} (que muestra las tareas que esten ejecutándose en la máquina anfitriona en tiempo real y actualizadolas en intervalos cortos de tiempo como puede apreciarse en la [Fig \ref{fig:top}]), el número de muestras perdidas aumentaba de forma exponencial. Es decir, para que las pérdidas realmente no fuesen significativas, el dispositivo sobre el que se ejecutase el programa, no debería estar ejecutándo nada adicional, o al menos no muchas más aplicaciones. Siendo conscientes de que esta situación era más propicia de condiciones de laboratorio, que de un dispositivo cualquiera en un momento determinado, sabíamos que algo teníamos que hacer para evitar esa pérdida de muestras en cualquier situación. Esta pérdida era básicamente producida por interrupciones que lanzaba el propio sistema operativo anfitrión cuando fuese preciso, otorgando la CPU a otros procesos que no fuesen el programa que recogía las muestras durante cierto tiempo, suficiente para significar una pérdida representativa.

\figura{Vectorial/top}{width=1\textwidth}{fig:top}%
{Ejemplo de salida al ejecutar comando \texttt{top} en una terminal linux}

Sabiendo que el sistema operativo no tenia por qué garantizarnos la CPU para el programa de usuario durante la mayor parte del tiempo que este se encuentra en ejecución, tuvimos que investigar la mejor forma de poder solucionar este problema, que podía llegar a ser crítico bajo las circunstancias propicias.

%-------------------------------------------------------------------
\subsection{Alternativas}
%-------------------------------------------------------------------
\label{cap3:subsec:alternativas}

Teniendo en mente el problema anteriormente nombrado, era momento de buscar alternativas para solventarlo. La solución más inmediata que pasó por nuestra cabeza, fue la de sustituir la distribución Debian que utilizabamos en la BBB por una distribución que estuviese pensada para trabajar con analisis y tratamientos de datos en tiempo real. De esta forma, el sistema operativo no interrumpiría el proceso de análisis de muestras otorgando la CPU a otras tareas, y por consiguiente, presumiblemente no se produciría la pérdida de ninguna muestra. Sin embargo está solución parecía poco sostenible, ya que el hecho de recurrir a una distribución tan específica podría no ser accesible para todo tipo de usuarios y dispositivos. Sin embargo, si se utilizase una distribución genérica, como el Debian que usabamos en aquel momento, no habría problemas, ya que se trata de una distribución de proposito general a la que cualquier usuario podría recurrir de manera relativamente sencilla.

Una vez estabamos decididos a mantener el sistema operativo, la solución tenía que encontrarse explorando otras posibles vías. Fue entonces, cuando se nos presentó la posibilidad de usar dos microprocesadores que tenía la BBB, denominadas PRUs (programable real-time unit). Estos dos microprocesadors con los que contabamos, podían ser programados específicamente para tratar procesos de análisis y recopilación de muestras en tiempo real. De esta forma, aunque el sistema operativo decidiese ceder el uso de la CPU a otro proceso, las PRUs podrían seguir tratando los procesos en tiempo real en segundo plano, sin necesidad de requerir la CPU principal, por lo que la pérdida de muestras se reduciría drásticamente, e incluso se evitaría, gracias a estos pequeños procesadores que incorpora la placa. Se trata de dos procesadores de alta frecuencia (200-MHz) de arquitectura de 32 bits específicamente diseñados para tratar con operaciones en tiempo real.

A continuación se enumeran los motivos por los que escogimos recurrir a las PRUs:

\begin{itemize}
  \item Tienen acceso a los pins, así como a la memoria interna de la BBB y a los periféricos del procesador AM3358 que incorpora.
  \item Estan diseñados para proveer software específico para periféricos como parte del sistema PRU-ICSS (Programmable Real-time Unit Industrial Control SubSystem).
  \item Son capaces de implementar soluciones relativamente simples a problemas complejos.
  \item Consta de un gran ancho de banda para comunicarse con la CPU principal y sus controladores, por lo que es improbable que se produzca el fenómeno conocido como cuello de botella. \footnote{Se denomina cuello de botella a la situación que se presenta cuando en un proceso productivo, una fase de producción es más lenta que otras, lo que ralentiza el proceso de producción global.}
  \item Tiene una gran comunidad de desarrolladores y multitud de recursos y proyectos que pueden ser consultados de forma gratuita.
\end{itemize}

%-------------------------------------------------------------------
\section{Programación en tiempo real}
%-------------------------------------------------------------------
\label{cap3:sec:tiemporeal}

Abordar la decisión de trabajar con las PRUs no es una tarea trivial. Requiere una gran labor de investigación previa, así como una sólida base en ciertos lenguajes de programación. Además, han sido necesarias tomar ciertas decisiones que han resultado cruciales para el correcto avance y desarrollo del proyecto, como ha podido ser en que lenguage programar las PRUs, o la configuración hardware para trabajar en el desarrollo.

%-------------------------------------------------------------------
\subsection{Decisiones de diseño}
%-------------------------------------------------------------------
\label{cap3:subsec:decisiones}

Cuando comenzó el desarrollo de este proyecto, existían dos posibles alternativas a escoger a la hora de elegir lenguaje con el que trabajar en las PRUs: 

\begin{itemize}
  \item \textbf{Posibilidad de programar en C:} Texas instruments introdujó en una de las últimas versiones de Code Composer Studio la posibilidad de programar en C para programar las PRU. Las herramientas que proporciona Texas Instruments para ello se denominan CGT (Code Generation Tools) y son relativamente sencillas de utilizar.
   \item \textbf{Posibilidad de programar en ensamblador:} Hay dos tipos de ensamblador disponibles para la PRU, pasm y clpru.
   \begin{itemize}
   		\item Pasm es el ensamblador original para la PRU. Este ensamblador suporta una unidad de traducción simple y se monta directamente a una imagen binaria (u otros formatos compatibles).
   		 \item Clpru es actualmente una herramienta de compilación completa que incluye ensamblador para la programación de la PRU. Soporta multitud de unidades de traducción y se monta directamente sobre ficheros objetos, los cuales deben ser enlazados al ejecutable final. \footnote{Cabe destacar que tanto pasm como clpru soportan prácticamente la misma sintaxis.}
   \end{itemize}
\end{itemize}

Ante las alternativas que se nos plantearon, la decisión final fue la de programar en ensamblador, concretamente en pasm. Se optó por esta descisión de diseño, ya que investigar cual de las posibilidades era la que más flexibilidad podía aportar al contexto en el que se situaba el proyecto, pasm resultó aportar un mayor control y una valiosa posibilidad de optimizar el código final.

%\medskip

%Y también ponemos el acrónimo \ac{CVS} para que no cruja.


%-------------------------------------------------------------------
%\section*{\NotasBibliograficas}
%-------------------------------------------------------------------
%\TocNotasBibliograficas

%Citamos algo para que aparezca en la bibliografía\ldots
%\citep{ldesc2e}

%\medskip

%Y también ponemos el acrónimo \ac{CVS} para que no cruja.

%Ten en cuenta que si no quieres acrónimos (o no quieres que te falle la compilación en ``release'' mientras no tengas ninguno) basta con que no definas la constante \verb+\acronimosEnRelease+ (en \texttt{config.tex}).


%-------------------------------------------------------------------
%\section*{\ProximoCapitulo}
%-------------------------------------------------------------------
%\TocProximoCapitulo

%...

% Variable local para emacs, para  que encuentre el fichero maestro de
% compilación y funcionen mejor algunas teclas rápidas de AucTeX
%%%
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../Tesis.tex"
%%% End:
